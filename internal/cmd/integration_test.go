package cmd_test

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestIntegrationCLIGeneratesOutputFile(t *testing.T) {
	// Find the project root directory
	_, thisFile, _, _ := runtime.Caller(0)
	projectRoot := filepath.Clean(filepath.Join(filepath.Dir(thisFile), "../.."))

	// Build the Linux binary before building the Docker image
	taskCmd := exec.Command("task", "build-linux")
	taskCmd.Dir = projectRoot
	taskOut, err := taskCmd.CombinedOutput()
	if err != nil {
		t.Fatalf("task build-linux failed: %v\nOutput:\n%s", err, string(taskOut))
	}
	binPath := filepath.Join(projectRoot, "dockerfilegraph")
	defer func() {
		if err := os.Remove(binPath); err != nil && !os.IsNotExist(err) {
			t.Errorf("failed to remove built binary %s: %v", binPath, err)
		}
	}()

	// Build the Docker image from the project root
	buildCmd := exec.Command("docker", "build", "-t", "dockerfilegraph-test", "-f", "Dockerfile", ".")
	buildCmd.Dir = projectRoot
	buildOut, err := buildCmd.CombinedOutput()
	if err != nil {
		t.Fatalf("docker build failed: %v\nOutput:\n%s", err, string(buildOut))
	}

	// Prepare temp dir for output
	tempDir := t.TempDir()
	// Copy example Dockerfile to temp dir
	dockerfileSrc := filepath.Join(projectRoot, "examples", "dockerfiles", "Dockerfile")
	dockerfileDst := filepath.Join(tempDir, "Dockerfile")
	content, err := os.ReadFile(dockerfileSrc)
	if err != nil {
		t.Fatalf("failed to read example Dockerfile from %s: %v", dockerfileSrc, err)
	}
	if err := os.WriteFile(dockerfileDst, content, 0644); err != nil {
		t.Fatalf("failed to write Dockerfile to temp dir %s: %v", dockerfileDst, err)
	}

	// Run the CLI in Docker to generate Dockerfile.dot
	dockerCmd := exec.Command(
		"docker", "run", "--rm",
		"-u", fmt.Sprintf("%d:%d", os.Getuid(), os.Getgid()),
		"-v", tempDir+":/data",
		"-w", "/data",
		"dockerfilegraph-test",
		"--filename", "Dockerfile", "--output", "dot",
	)
	dockerOut, err := dockerCmd.CombinedOutput()
	if err != nil {
		t.Fatalf("docker run CLI failed: %v\nOutput:\n%s", err, string(dockerOut))
	}

	// Read the DOT file generated by the CLI
	dotFile := filepath.Join(tempDir, "Dockerfile.dot")
	outputBytes, err := os.ReadFile(dotFile)
	if err != nil {
		t.Fatalf("failed to read generated dot file %s: %v", dotFile, err)
	}

	checkGoldenFile(t, outputBytes)
}

func checkGoldenFile(t *testing.T, dotBytes []byte) {
	_, thisFile, _, _ := runtime.Caller(0)
	goldenDir := filepath.Join(filepath.Dir(thisFile), "testdata")
	goldenFile := filepath.Join(goldenDir, "Dockerfile.golden.dot")

	if _, err := os.Stat(goldenFile); os.IsNotExist(err) {
		if err := os.MkdirAll(goldenDir, 0755); err != nil {
			t.Fatalf("failed to create testdata dir: %v", err)
		}
		if err := os.WriteFile(goldenFile, dotBytes, 0644); err != nil {
			t.Fatalf("failed to write golden file: %v", err)
		}
		t.Logf("golden file did not exist, created: %s", goldenFile)
	} else {
		goldenBytes, err := os.ReadFile(goldenFile)
		if err != nil {
			t.Fatalf("failed to read golden file: %v", err)
		}
		diff := cmp.Diff(string(goldenBytes), string(dotBytes))
		if diff != "" {
			t.Errorf(
				"output DOT does not match golden file.\n"+
					"To update, delete %s and re-run the test.\n"+
					"Diff (-want +got):\n%s",
				goldenFile, diff,
			)
		}
	}
}
